#pragma once
#include "utils.h"
#include "clasp.h"
#include <glm/vec3.hpp>
#include <vector>
#include <span>

/*

Half Edge data structure
http://sccg.sk/~samuelcik/dgs/half_edge.pdf

V=vertex
E=vertex.edge.vertex
N=vertex.edge.next.vertex
P=vertex.edge.next.next.pair.next.vertex

     E
    / \
   V---N
    \ /
     P
	 

*/

// Might be worth turning this whole thing into a class of sorts?
// It's a little bit messy currently...
// We need some more memory efficiency in here too

// I wish enum class was better
enum FaceFlags : char
{
	FF_NONE = 0,
	FF_CUT = 1,
	FF_CONVEX = 2,
	FF_MESH_PART = 4
};
MAKE_BITFLAG(FaceFlags);
enum EdgeFlags : char
{
	EF_NONE = 0,
	EF_SLICED = 1, // An edge that has been sliced
	EF_PART_EDGE = 2, // An edge that belongs to the part
	EF_OUTER = 4, // An edge that's on the outer part of the face
};
MAKE_BITFLAG(EdgeFlags);

struct halfEdge_t;
struct face_t;
struct mesh_t;

struct vertex_t
{
	// Should refer back to the face's verts
	clasp_ref<glm::vec3> vert;

	// The edge that stems out of this vert
	clasp_ref<halfEdge_t> edge;
};

template<>
void breakClaspCycles(vertex_t&);


struct halfEdge_t
{
	// This edge stems out of a vertex. vert is the vertex at the end of this edge.
	clasp_ref<vertex_t> vert;

	// This edge is half of another edge. This is the other side of the edge located on another face.
	// NOTE: This definitely is optional. Others, no.
	clasp_ref<halfEdge_t> pair;

	//TODO: Magnus: remove the optional off most clasp_ref's, they are bloat.
	// The face this edge belongs to.
	clasp_ref<face_t> face;

	// Next edge. Same as vert->edge.
	clasp_ref<halfEdge_t> next;

	EdgeFlags flags = EdgeFlags::EF_NONE;
};

template<>
void breakClaspCycles(halfEdge_t&);

struct meshPart_t;

struct face_t
{
	// Do we really need vectors for this?
	//TODO: These edge and vert vectors shouldn't exist. halfEdges should own eachother, and vertex 
	// clasp_ref<halfEdge_t> edge;

	// These edges use the verts 
	// Not ordered!
	std::vector<clasp<halfEdge_t>> edges;

	// Not ordered!
	std::vector<clasp<vertex_t>> verts;

	// What do we belong to? Could be a meshpart, face, or etc.
	clasp_ref<face_t> parent;


	FaceFlags flags = FaceFlags::FF_NONE;
};

template<>
void breakClaspCycles(face_t&);

// Axis Aligned Bounding Box. Absolute minimum and maximum of a shape
struct aabb_t
{
	glm::vec3 min;
	glm::vec3 max;
};

struct slicedMeshPartData_t
{
	// Convexified of the mesh. Use for geo testing and etc.
	std::vector<clasp<face_t>> collision;

	// A triangulated representation of the face. This is what gets rendered. 
	//std::vector<face_t*> tris;

	// List of cut vertexes used by this part. Do not delete! We don't own these.
	std::vector<clasp_ref<glm::vec3>> cutVerts;

	// List of faces produced by the cut. Most likely concave.
	std::vector<clasp<face_t>> faces;
};

// A mesh part is a face that is part of a larger mesh that holds more faces
struct meshPart_t : public face_t
{
	meshPart_t(clasp_ref<mesh_t> mesh) : mesh(mesh) { flags = FaceFlags::FF_MESH_PART; }

	// Neither the collision vector nor the tris vector should be used for true mesh editing, as they are constantly regenerated.

	// Convexified representation of the mesh part. Use for geo testing and etc.
	std::vector<clasp<face_t>> collision;

	// A triangulated representation of the face. This is what gets rendered.
	std::vector<clasp<face_t>> tris;

	// Data that gets populated when this mesh gets sliced. When this is not nullptr, it should take priority over our collisions and tris
	clasp<slicedMeshPartData_t> sliced;

	// What mesh do we belong to
	clasp_ref<mesh_t> mesh;

	// Precomputed normal of the part. Generated by defineMeshPartFaces
	glm::vec3 normal;
};

template<>
void breakClaspCycles(meshPart_t&);

struct mesh_t
{
	mesh_t() = default;
	// cannot safely be default-copied, as members refer to eachother's allocations
	// does anyone feel like implementing that?
	mesh_t(mesh_t const &) = delete;
	// can be safely moved, because nothing references mesh_t's allocation itself.
	mesh_t(mesh_t&&) = default;
	// same for copy assignment
	mesh_t const &operator=(mesh_t const &) = delete;

	// The faces of this mesh
	std::vector<clasp<meshPart_t>> parts;
	
	// Not ordered! Do no depend on this!
	// Pointers so that adding doesn't delete the memory
	std::vector<clasp<glm::vec3>> verts;

	// Calculated from part aabbs
	//aabb_t aabb;

	// Transform of the mesh
	glm::vec3 origin;
};

// A mesh that can be sliced by other meshes
struct cuttableMesh_t : public mesh_t
{
	/*
	// These cut into this mesh without changing the real structure of it
	std::vector<mesh_t*> cutters;

	// We cut these meshes
	std::vector<mesh_t*> cutting;
	*/

	// Not ordered! Do no depend on this!
	// Pointers so that adding doesn't delete the memory
	// Added during cutting
	std::vector<clasp<glm::vec3>> cutVerts;
};

template<>
void breakClaspCycles(cuttableMesh_t&);

// Returns start of the points within mesh.verts
std::span<clasp<glm::vec3>> addMeshVerts(mesh_t& mesh, std::span<glm::vec3> points);

// Does not add points to mesh! Only adds a face
clasp_ref<meshPart_t> addMeshFace(clasp_ref<mesh_t> mesh, std::span<clasp_ref<glm::vec3>> points);

void defineMeshPartFaces(clasp_ref<meshPart_t> mesh);


aabb_t meshAABB(mesh_t& mesh);
void recenterMesh(mesh_t& mesh);
glm::vec3 faceCenter(face_t const &face);
glm::vec3 faceNormal(face_t const &face, glm::vec3* outCenter = nullptr);
glm::vec3 convexFaceNormal(face_t const &face);
glm::vec3 vertNextNormal(vertex_t const &vert);
unsigned int edgeLoopCount(vertex_t &sv);
inline unsigned int edgeLoopCount(halfEdge_t* sh) { return edgeLoopCount(*sh->vert); }


void cloneFaceInto(face_t& in, clasp_ref<face_t> cloneOut);

inline clasp_ref<meshPart_t> parentPart(clasp_ref<face_t> f)
{
	if (!f)
		return nullptr;

	if (f->flags & FaceFlags::FF_MESH_PART)
		return f.cast<meshPart_t>();

	if (f->parent)
		return parentPart(f->parent);

	return nullptr;
}

inline clasp_ref<mesh_t> parentMesh(clasp_ref<face_t> f)
{
	if (!f)
		return nullptr;

	auto part = parentPart(f);
	if (part)
		return part->mesh;

	return nullptr;
}


// Bulks up an AABB if the point is outside
aabb_t addPointToAABB(aabb_t aabb, glm::vec3 point);

// When called, primary face should own both faces' halfedges; those marked with other as face will be moved.
// TODO: these functions will be unnecessary once halfEdges own the world.
void settleHECustody(clasp_ref<face_t> primary, clasp_ref<face_t> other);
void settleVertCustody(clasp_ref<face_t> face, clasp_ref<face_t> newFace);


// Generates a file out.dot that can be fed to graphViz
void graphFace(clasp_ref<face_t> tasty, char const *filename_postfix = "");
